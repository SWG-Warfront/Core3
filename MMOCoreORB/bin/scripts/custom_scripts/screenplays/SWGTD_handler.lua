-- ~SWG Talk Dirty~ (The go-to app for fast vendor and convo design)
-- By: Mindsoft (Property of BloodfinEMU.net)

-- ??? TODO add required faction standing as a test???

-----------------------------------------------(GENERIC RUN SCREEN HANDLER with Function Handling)
SWGTD_handler = conv_handler:new{}
function SWGTD_handler:generic_runScreenHandlers( conversationTemplate, conversingPlayer, conversingNPC, selectedOption, conversationScreen, quest )
	local conversation = LuaConversationTemplate( conversationTemplate )
	local screen = LuaConversationScreen( conversationScreen )
	local screenID = screen:getScreenID()
	local nextConversationScreen = conversation:getScreen(screenID)
	if quest ~= nil then
		for key,value in pairs(quest) do
			if screenID == key then
				local feedback = quest[key](quest)
				if feedback ~= nil and type(feedback) == "string" then				
					nextConversationScreen = conversation:getScreen(feedback)
				end
				break
			end
		end
	end
	return nextConversationScreen
end
---------------------------------------------(SUI Window 1: Category Selection)
function SWGTD_handler:categoryChoice(quest)
	local QuestString = readStringData(SceneObject(quest.player):getObjectID() .. ":SWGTD_purchase_QuestString")
	local func = load('return '..QuestString..'.tests')
	local testList = func()
	func = load('return '..QuestString..'.groupTable')
	local GroupList = func()
	func = load('return '..QuestString..'.groupSuiTables')
	local groupSuiTables = func()
	
	local sui = SuiListBox.new("SWGTD_handler", "itemChoice")
	sui.setTitle(groupSuiTables[1][1])--"SWGTD Test Handler GROUP SELECTION")
	sui.setPrompt(groupSuiTables[1][2])--"This is an example of the vendor conversation generated by the SWGTD app.\n\nSelect a (GROUP)")
	sui.setTargetNetworkId(SceneObject(quest.target):getObjectID())
	sui.setForceCloseDistance(16)

	for k,v in ipairs(GroupList) do
		sui.add(v, "")

	end
	sui.sendTo(quest.player)
	return
end

---------------------------------------------(SUI Window 2: Item Selection)
function SWGTD_handler:itemChoice(pCreature, pSui, eventIndex, choice)
	if ((eventIndex == 1) or (pCreature == nil) or (choice == "-1")) then
		deleteStringData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_QuestString")
		return
	end
	local QuestString = readStringData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_QuestString")
	local func = load('return '..QuestString..'.itemsByGroup')
	local ItemList = func()
	func = load('return '..QuestString..'.groupSuiTables')
	local groupSuiTables = func()
	func = load('return '..QuestString..'.CurrencyType')
	local CurrencyType = func() --Currency Type ie. Credits,Items,Faction,Experience

	local pPageData = LuaSuiBoxPage(pSui):getSuiPageData()
	if (pPageData == nil) then
		deleteStringData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_QuestString")
		return
	end

	local suiPageData = LuaSuiPageData(pPageData)
	local targetID = suiPageData:getTargetNetworkId()
	local target = getSceneObject(targetID)
	local sui = SuiListBox.new("SWGTD_handler", "handleSuiPurchase")
	sui.setTitle(groupSuiTables[1][1])
	sui.setPrompt(groupSuiTables[2][choice+1])
	sui.setTargetNetworkId(SceneObject(target):getObjectID())
	sui.setForceCloseDistance(16)
	local str = ""
	for k,v in ipairs(ItemList[choice+1]) do
		str = (string.format("%-45s%s)",v[1],"("..tostring(v[2]).." "..CurrencyType))
		sui.add(str,"")
	end

	writeData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_option",(choice+1))
	sui.sendTo(pCreature)

	return 0
end

---------------------------------------------(Process Purchase)
function SWGTD_handler:handleSuiPurchase(pCreature, pSui, eventIndex, selected)
	if ((eventIndex == 1) or (pCreature == nil) or (selected == "-1")) then
		deleteData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_option")
		return
	end

	local experienceMultiplier = 1 --     <--  --  -- this value used as divisor on servers with bonus xp

	--Load Table Data from calling handler
	local QuestString = readStringData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_QuestString")
	deleteStringData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_QuestString")
	local func = load('return '..QuestString..'.groupTable')
	local GroupList = func()--List of Groups
	func = load('return '..QuestString..'.itemsByGroup')
	local ItemList = func()--List of items by group
	func = load('return '..QuestString..'.CurrencyType')
	local CurrencyType = func() --Currency Type ie. Credits,Items,Faction,Experience
	func = load('return '..QuestString..'.CurrencyData')
	local CurrencyData = func() --Secondary currency data ie. xpName,factionName,experienceName,itemIFF
	func = load('return '..QuestString..'.lootType')
	local lootType = func() --Item Reward Type, (true = loot group / false = iff)
	
	--get player object and group choice (clean up old data)
	local creature = CreatureObject(pCreature)
	local category = readData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_option")
	deleteData(SceneObject(pCreature):getObjectID() .. ":SWGTD_purchase_option")

	local group = (GroupList[category])
	if (category == "") or (group == nil) then
		return 0
	end
	
	--aquire variable data
	local Group = ItemList[category]
	local itemName = (Group[selected+1][1])
	local purchaseCost = (Group[selected+1][2])
	local purchaseIFF = (Group[selected+1][3])

	-- Collect player information and thier inventory.
	local pInventory = creature:getSlottedObject("inventory")
	local inventory = LuaSceneObject(pInventory)
	local containerSize = inventory:getContainerObjectsSize()
	if (itemName == nil) or (purchaseCost == nil) or (purchaseIFF == nil) then
		--print("\n\nBad Table Data in ~SWGTD~ Handler\n\n")
		return 0
	end

        -- Insufficent Space
	if (SceneObject(pInventory):isContainerFullRecursive()) then
		creature:sendSystemMessage("You do not have enough inventory space.")  
		return 0
	end

	-- get player object
	local pGhost = creature:getPlayerObject()
	if (pGhost == nil) then
		return 0
	end

	local i = 0
	--Calculate Smuggler Discount
	local smugglerDiscount = 1.0
	if creature:hasSkill("combat_smuggler_master") then
			smugglerDiscount = .75
	elseif creature:hasSkill("combat_smuggler_underworld_01") then
			smugglerDiscount = .90
	end

--Process Transaction
	--Process Credit Transaction
	if (CurrencyType == "Credits") then
		local credits = creature:getCashCredits()
		if not (credits > purchaseCost) then
			--Insufficent Credits
			creature:sendSystemMessage("You have insufficient credits.")
			return 0
		end
		--Remove Required Credits
		creature:subtractCashCredits(purchaseCost*smugglerDiscount)

	--Process Item Transaction
	elseif (CurrencyType == "Items") then
		local itemCounter = 0

		--Check for Required Transaction Items
		for i = 0, containerSize - 1, 1 do
			local pInvObj = inventory:getContainerObject(i)
			local invObj = LuaSceneObject(pInvObj)
			if (invObj:getTemplateObjectPath() == CurrencyData) then
				itemCounter = itemCounter + 1
			end
		end
		  
		-- Insufficent Items
		if itemCounter < purchaseCost then            
			creature:sendSystemMessage("You have insufficient items.")
			return 0
		end
	
		-- Remove Barter Items
		for i = containerSize - 1 , 0 , -1 do
		  	local pInvObj = inventory:getContainerObject(i)
			local invObj = LuaSceneObject(pInvObj)
			if (invObj:getTemplateObjectPath() == CurrencyData and purchaseCost > 0 ) then
				purchaseCost = purchaseCost - 1
				invObj:destroyObjectFromWorld()
				invObj:destroyObjectFromDatabase()
			end
		end

	--Process Experience Transaction
	elseif (CurrencyType == "Experience") then
		if ((LuaPlayerObject(pGhost):getExperience(CurrencyData))>purchaseCost)then
			--remove Experience
			creature:awardExperience(CurrencyData, (purchaseCost * -1)/experienceMultiplier, false)
		else	--Insufficent Experience
			creature:sendSystemMessage("You have insufficient experience.")
			return 0
		end

	--Process Faction Transaction
	elseif (CurrencyType == "Faction") then
		local factionStanding = PlayerObject(pGhost):getFactionStanding(CurrencyData)
		local itemCost = math.ceil(purchaseCost * smugglerDiscount)
		-- Insufficent Faction
		if (factionStanding < (itemCost + 200)) then
			creature:sendSystemMessage("You have insufficient faction (you must reserve at least 200).")
			return 0
		end
			--Remove Faction Standing
			PlayerObject(pGhost):decreaseFactionStanding(CurrencyData, itemCost)
	else
		return 0
	end

	-- Give player purchased item.
				
	local pItem;
	if (lootType == 1) then
		func = load('return '..QuestString..'.lootWeight')
		local lootWeight = func() --Vendor loot Group weight
		if (type(lootWeight) == "table") then
			--print("loot Weight table found!")
			for k,v in ipairs(lootWeight) do
				--print("pairs ",k,v)
			end
			lootWeight = lootWeight[category]
			if lootWeight < 1 then
				--print("\niff item found in table!\n")
				pItem = giveItem(pInventory, purchaseIFF, -1)
				if pItem == nil then
					creature:sendSystemMessage("You could not receive: "..itemName..". Please screenshot this and consult a GM for assistance.")
					return 0
				end
				creature:sendSystemMessage("You have received: "..itemName..".")
				return 0;
			end
			--print("lootWeight is:",lootWeight)
		else
			if lootWeight < 1 then
				lootWeight = 0
			end
		end
		pItem = (createLoot(pInventory, purchaseIFF, lootWeight, true))
	else
 		pItem = giveItem(pInventory, purchaseIFF, -1)
		if pItem == nil then
			creature:sendSystemMessage("You could not receive: "..itemName..". Please screenshot this and consult a GM for assistance.")
			return 0
		end
	end
	creature:sendSystemMessage("You have received: "..itemName..".")
	return 0
end

function SWGTD_handler:validatePlayer(pCreature, testList)
	--testList=([1]faction, [2]skill, [3]screenplay, [4]screenplay-state, [5]race) 
	--???TODO add is-Visible? , return data for clonescreens
	local test = true
	local creature = CreatureObject(pCreature)
	local pGhost = creature:getPlayerObject()
	if (pGhost == nil) or (creature == nil) then
		--print("category :",category)
		--print("Null Creature or Player Object from pCreature in SWGTD_handler:validatePlayer",pCreature)
		return false
	end

	--print("running tests")
	if (testList[1]~=0) then--Faction Requirement
		--factionHashCode = { neutral = 0, rebel = 370444368, imperial = 3679112276 },
		if ((testList[1]=="rebel") or (testList[1]=="rebelOvert")) and (not (creature:getFaction() == 370444368)) then
			creature:sendSystemMessage("You are the wrong faction, Rebel is required for this interaction.")
			return false
		elseif((testList[1]=="imperial") or (testList[1]=="imperialOvert")) and (not (creature:getFaction() == 3679112276)) then
			creature:sendSystemMessage("You are the wrong faction, Imperial is required for this interaction.")
			return false
		elseif(testList[1]=="neutral") and (not (creature:getFaction() == 0)) then
			creature:sendSystemMessage("You are the wrong faction, Neutral is required for this interaction.")
			return false
		elseif((testList[1]=="overt") or (testList[1]=="rebelOvert") or (testList[1]=="imperialOvert")) and (not creature:isOvert()) then
			creature:sendSystemMessage("You are the wrong combat state, Overt status is required for this interaction.")
			return false
		elseif(testList[1]=="jedi") and (not PlayerObject(pGhost):isJedi()) then
			creature:sendSystemMessage("You must be a Jedi for this interaction.")
			return false
		end
	end

	if (testList[5]~=(-1)) then--Player Race Requirement
		if (not (creature:getSpecies() == testList[5]))  then
			creature:sendSystemMessage("Your are not the correct species for this interaction.")
			return false
		end
	end

	if (testList[2]~="0") then--Skill Requirement
		if (not creature:hasSkill(testList[2])) then
			creature:sendSystemMessage("You are missing a required skill, "..testList[2].." is required for this interaction.")
			return false
		end
	end

	if (testList[3]~="0") and (testList[4]) then--Screenplay-State Requirement
		if (not creature:hasScreenPlayState(testList[4], testList[3])) then
			creature:sendSystemMessage("You are not yet able to make this interaction.")
			return false
		end
	end
	return true
end
